binary-debuggable-source
0000 0000 f emutest.asm
0000 0000 s ; EMUTEST.COM - Emulator ROM and RAM diagnostics
0000 0000 s ; Based on diag4.mac from Non-Linear Systems, Inc. (1983)
0000 0000 s ; Implements proper ROM bank switching by relocating code to 0x8000
0000 0000 s ; 
0000 0000 s ; Test 3 (Video RAM) uses SY6545 CRTC transparent addressing:
0000 0000 s ;   Port 0x1C: Register select (R18=addr_hi, R19=addr_lo)
0000 0000 s ;   Port 0x1D: Register data
0000 0000 s ;   Port 0x1F: VRAM data read/write + strobe control
0000 0000 s ;   Wait for port 0x1C bit 7 = 1 (Update Ready) after strobe
0000 0000 s 
0000 0000 s ; CP/M BDOS calls
0000 0000 s bdos:           equ     5
0000 0000 s conout:         equ     2
0000 0000 s prtstr:         equ     9
0000 0000 s 
0000 0000 s ; Kaypro 4-84 ports
0000 0000 s bitport:        equ     014h
0000 0000 s 
0000 0000 s ; SY6545 CRTC ports and commands (from diag4.mac univ=true)
0000 0000 s crtc_reg:       equ     01Ch    ; CRTC register select
0000 0000 s crtc_data:      equ     01Dh    ; CRTC register data
0000 0000 s crtc_vram:      equ     01Fh    ; CRTC VRAM data / strobe
0000 0000 s strcmd:         equ     01Fh    ; Strobe command value
0000 0000 s 
0100 0100 s         org     0100h
0100 0100 s 
0100 0100 s ; ============================================================================
0100 0100 s ; Main program
0100 0100 s ; ============================================================================
0100 0100 s start:
0100 0100 d 31fc04
0100 0100 u 03 01
0100 0100 s         ld      sp, stack
0103 0103 s 
0103 0103 s         ; Print banner
0103 0103 d 11dc03
0103 0103 u 03 01
0103 0103 s         ld      de, msg_banner
0106 0106 d cdb903
0106 0106 u 03 01
0106 0106 s         call    print
0109 0109 s 
0109 0109 s         ; Test 1: ROM checksum
0109 0109 d cd1901
0109 0109 u 03 01
0109 0109 s         call    rom_test
010c 010c s 
010c 010c s         ; Test 2: RAM tests
010c 010c d cd6901
010c 010c u 03 01
010c 010c s         call    ram_test
010f 010f s 
010f 010f s         ; Test 3: Video RAM test (SY6545 CRTC)
010f 010f d cd5002
010f 010f u 03 01
010f 010f s         call    vram_test
0112 0112 s 
0112 0112 s         ; Print completion message
0112 0112 d 119f04
0112 0112 u 03 01
0112 0112 s         ld      de, msg_done
0115 0115 d cdb903
0115 0115 u 03 01
0115 0115 s         call    print
0118 0118 s 
0118 0118 s         ; Return to CP/M
0118 0118 d c7
0118 0118 u 01 01
0118 0118 s         rst     0
0119 0119 s 
0119 0119 s ; ============================================================================
0119 0119 s ; ROM Checksum Test
0119 0119 s ; Copies test code to 0x8000, executes there to read ROM while banked in
0119 0119 s ; ============================================================================
0119 0119 s rom_test:
0119 0119 d 112e04
0119 0119 u 03 01
0119 0119 s         ld      de, msg_rom
011c 011c d cdb903
011c 011c u 03 01
011c 011c s         call    print
011f 011f s 
011f 011f s         ; Copy ROM test routine to 0x8000
011f 011f d 213f01
011f 011f u 03 01
011f 011f s         ld      hl, rom_code_start
0122 0122 d 110080
0122 0122 u 03 01
0122 0122 s         ld      de, 08000h
0125 0125 d 012a00
0125 0125 u 03 01
0125 0125 s         ld      bc, rom_code_end - rom_code_start
0128 0128 d edb0
0128 0128 u 02 01
0128 0128 s         ldir
012a 012a s 
012a 012a s         ; Jump to relocated code at 0x8000
012a 012a s         ; It will calculate checksum and return here via rom_return
012a 012a d c30080
012a 012a u 03 01
012a 012a s         jp      08000h
012d 012d s 
012d 012d s rom_return:
012d 012d s         ; HL now contains the checksum (returned from relocated code)
012d 012d d e5
012d 012d u 01 01
012d 012d s         push    hl
012e 012e s 
012e 012e s         ; Print checksum value
012e 012e d 114204
012e 012e u 03 01
012e 012e s         ld      de, msg_chksum
0131 0131 d cdb903
0131 0131 u 03 01
0131 0131 s         call    print
0134 0134 d e1
0134 0134 u 01 01
0134 0134 s         pop     hl
0135 0135 d cdbe03
0135 0135 u 03 01
0135 0135 s         call    print_hex16
0138 0138 s 
0138 0138 d 11b904
0138 0138 u 03 01
0138 0138 s         ld      de, msg_crlf
013b 013b d cdb903
013b 013b u 03 01
013b 013b s         call    print
013e 013e d c9
013e 013e u 01 01
013e 013e s         ret
013f 013f s 
013f 013f s ; ============================================================================
013f 013f s ; ROM test code - gets copied to 0x8000 and executed there
013f 013f s ; This code must be position-independent or use absolute addresses at 0x8000
013f 013f s ; ============================================================================
013f 013f s rom_code_start:
013f 013f s         ; This code runs at 0x8000
013f 013f s         
013f 013f s         ; Save current bank state
013f 013f d db14
013f 013f u 02 01
013f 013f s         in      a, (bitport)
0141 0141 d f5
0141 0141 u 01 01
0141 0141 s         push    af
0142 0142 s 
0142 0142 s         ; Switch to ROM bank (set bit 7)
0142 0142 d f680
0142 0142 u 02 01
0142 0142 s         or      080h
0144 0144 d d314
0144 0144 u 02 01
0144 0144 s         out     (bitport), a
0146 0146 s 
0146 0146 s         ; Calculate checksum of first 4KB (0x0000-0x0FFF)
0146 0146 s         ; HL = checksum accumulator, DE = address pointer
0146 0146 d 210000
0146 0146 u 03 01
0146 0146 s         ld      hl, 0
0149 0149 d 110000
0149 0149 u 03 01
0149 0149 s         ld      de, 0
014c 014c d 010010
014c 014c u 03 01
014c 014c s         ld      bc, 01000h          ; 4KB = 0x1000 bytes
014f 014f s 
014f 014f s rom_calc_loop:
014f 014f d 1a
014f 014f u 01 01
014f 014f s         ld      a, (de)             ; Read ROM byte
0150 0150 d 85
0150 0150 u 01 01
0150 0150 s         add     a, l                ; Add to low byte of checksum
0151 0151 d 6f
0151 0151 u 01 01
0151 0151 s         ld      l, a
0152 0152 d 3001
0152 0152 u 02 01
0152 0152 s         jr      nc, rom_no_carry
0154 0154 d 24
0154 0154 u 01 01
0154 0154 s         inc     h                   ; Carry to high byte
0155 0155 s rom_no_carry:
0155 0155 d 13
0155 0155 u 01 01
0155 0155 s         inc     de
0156 0156 d 0b
0156 0156 u 01 01
0156 0156 s         dec     bc
0157 0157 d 78
0157 0157 u 01 01
0157 0157 s         ld      a, b
0158 0158 d b1
0158 0158 u 01 01
0158 0158 s         or      c
0159 0159 d 20f4
0159 0159 u 02 01
0159 0159 s         jr      nz, rom_calc_loop
015b 015b s 
015b 015b s         ; Save checksum in IX (safe across bank switch)
015b 015b d e5
015b 015b u 01 01
015b 015b s         push    hl
015c 015c d dde1
015c 015c u 02 01
015c 015c s         pop     ix
015e 015e s 
015e 015e s         ; Switch back to RAM bank (clear bit 7)
015e 015e d f1
015e 015e u 01 01
015e 015e s         pop     af                  ; Get saved port value
015f 015f d cbbf
015f 015f u 02 01
015f 015f s         res     7, a
0161 0161 d d314
0161 0161 u 02 01
0161 0161 s         out     (bitport), a
0163 0163 s 
0163 0163 s         ; Restore checksum to HL from IX
0163 0163 d dde5
0163 0163 u 02 01
0163 0163 s         push    ix
0165 0165 d e1
0165 0165 u 01 01
0165 0165 s         pop     hl
0166 0166 s 
0166 0166 s         ; Jump back to main code (absolute address)
0166 0166 d c32d01
0166 0166 u 03 01
0166 0166 s         jp      rom_return
0169 0169 s 
0169 0169 s rom_code_end:
0169 0169 s 
0169 0169 s ; ============================================================================
0169 0169 s ; RAM Tests
0169 0169 s ; ============================================================================
0169 0169 s ram_test:
0169 0169 s         ; Test region 0x4000-0x7FFF
0169 0169 d 114504
0169 0169 u 03 01
0169 0169 s         ld      de, msg_ram1
016c 016c d cdb903
016c 016c u 03 01
016c 016c s         call    print
016f 016f s 
016f 016f d 210040
016f 016f u 03 01
016f 016f s         ld      hl, 04000h
0172 0172 d 11ff7f
0172 0172 u 03 01
0172 0172 s         ld      de, 07FFFh
0175 0175 d cdbd01
0175 0175 u 03 01
0175 0175 s         call    sliding_data
0178 0178 d 2013
0178 0178 u 02 01
0178 0178 s         jr      nz, ram_fail1
017a 017a s 
017a 017a d 210040
017a 017a u 03 01
017a 017a s         ld      hl, 04000h
017d 017d d 11ff7f
017d 017d u 03 01
017d 017d s         ld      de, 07FFFh
0180 0180 d cdfe01
0180 0180 u 03 01
0180 0180 s         call    address_data
0183 0183 d 2008
0183 0183 u 02 01
0183 0183 s         jr      nz, ram_fail1
0185 0185 s 
0185 0185 d 119104
0185 0185 u 03 01
0185 0185 s         ld      de, msg_pass
0188 0188 d cdb903
0188 0188 u 03 01
0188 0188 s         call    print
018b 018b d 1806
018b 018b u 02 01
018b 018b s         jr      ram_test2
018d 018d s 
018d 018d s ram_fail1:
018d 018d d 119804
018d 018d u 03 01
018d 018d s         ld      de, msg_fail
0190 0190 d cdb903
0190 0190 u 03 01
0190 0190 s         call    print
0193 0193 s 
0193 0193 s ram_test2:
0193 0193 s         ; Test region 0x8000-0xBFFF
0193 0193 d 115e04
0193 0193 u 03 01
0193 0193 s         ld      de, msg_ram2
0196 0196 d cdb903
0196 0196 u 03 01
0196 0196 s         call    print
0199 0199 s 
0199 0199 d 210080
0199 0199 u 03 01
0199 0199 s         ld      hl, 08000h
019c 019c d 11ffbf
019c 019c u 03 01
019c 019c s         ld      de, 0BFFFh
019f 019f d cdbd01
019f 019f u 03 01
019f 019f s         call    sliding_data
01a2 01a2 d 2012
01a2 01a2 u 02 01
01a2 01a2 s         jr      nz, ram_fail2
01a4 01a4 s 
01a4 01a4 d 210080
01a4 01a4 u 03 01
01a4 01a4 s         ld      hl, 08000h
01a7 01a7 d 11ffbf
01a7 01a7 u 03 01
01a7 01a7 s         ld      de, 0BFFFh
01aa 01aa d cdfe01
01aa 01aa u 03 01
01aa 01aa s         call    address_data
01ad 01ad d 2007
01ad 01ad u 02 01
01ad 01ad s         jr      nz, ram_fail2
01af 01af s 
01af 01af d 119104
01af 01af u 03 01
01af 01af s         ld      de, msg_pass
01b2 01b2 d cdb903
01b2 01b2 u 03 01
01b2 01b2 s         call    print
01b5 01b5 d c9
01b5 01b5 u 01 01
01b5 01b5 s         ret
01b6 01b6 s 
01b6 01b6 s ram_fail2:
01b6 01b6 d 119804
01b6 01b6 u 03 01
01b6 01b6 s         ld      de, msg_fail
01b9 01b9 d cdb903
01b9 01b9 u 03 01
01b9 01b9 s         call    print
01bc 01bc d c9
01bc 01bc u 01 01
01bc 01bc s         ret
01bd 01bd s 
01bd 01bd s ; ============================================================================
01bd 01bd s ; Sliding Data Test
01bd 01bd s ; Input: HL = start, DE = end
01bd 01bd s ; Output: Z=pass, NZ=fail
01bd 01bd s ; ============================================================================
01bd 01bd s sliding_data:
01bd 01bd d e5
01bd 01bd u 01 01
01bd 01bd s         push    hl
01be 01be d d5
01be 01be u 01 01
01be 01be s         push    de
01bf 01bf s 
01bf 01bf d 0601
01bf 01bf u 02 01
01bf 01bf s         ld      b, 1            ; Initial pattern
01c1 01c1 s sd_outer:
01c1 01c1 d 0e08
01c1 01c1 u 02 01
01c1 01c1 s         ld      c, 8            ; 8 bit positions
01c3 01c3 s 
01c3 01c3 s sd_bit:
01c3 01c3 d d1
01c3 01c3 u 01 01
01c3 01c3 s         pop     de
01c4 01c4 d e1
01c4 01c4 u 01 01
01c4 01c4 s         pop     hl
01c5 01c5 d e5
01c5 01c5 u 01 01
01c5 01c5 s         push    hl
01c6 01c6 d d5
01c6 01c6 u 01 01
01c6 01c6 s         push    de
01c7 01c7 s 
01c7 01c7 s sd_write:
01c7 01c7 d 70
01c7 01c7 u 01 01
01c7 01c7 s         ld      (hl), b
01c8 01c8 d 7c
01c8 01c8 u 01 01
01c8 01c8 s         ld      a, h
01c9 01c9 d ba
01c9 01c9 u 01 01
01c9 01c9 s         cp      d
01ca 01ca d 2004
01ca 01ca u 02 01
01ca 01ca s         jr      nz, sd_winc
01cc 01cc d 7d
01cc 01cc u 01 01
01cc 01cc s         ld      a, l
01cd 01cd d bb
01cd 01cd u 01 01
01cd 01cd s         cp      e
01ce 01ce d 2803
01ce 01ce u 02 01
01ce 01ce s         jr      z, sd_verify
01d0 01d0 s sd_winc:
01d0 01d0 d 23
01d0 01d0 u 01 01
01d0 01d0 s         inc     hl
01d1 01d1 d 18f4
01d1 01d1 u 02 01
01d1 01d1 s         jr      sd_write
01d3 01d3 s 
01d3 01d3 s sd_verify:
01d3 01d3 d d1
01d3 01d3 u 01 01
01d3 01d3 s         pop     de
01d4 01d4 d e1
01d4 01d4 u 01 01
01d4 01d4 s         pop     hl
01d5 01d5 d e5
01d5 01d5 u 01 01
01d5 01d5 s         push    hl
01d6 01d6 d d5
01d6 01d6 u 01 01
01d6 01d6 s         push    de
01d7 01d7 s 
01d7 01d7 s sd_read:
01d7 01d7 d 7e
01d7 01d7 u 01 01
01d7 01d7 s         ld      a, (hl)
01d8 01d8 d b8
01d8 01d8 u 01 01
01d8 01d8 s         cp      b
01d9 01d9 d 201d
01d9 01d9 u 02 01
01d9 01d9 s         jr      nz, sd_fail
01db 01db d 7c
01db 01db u 01 01
01db 01db s         ld      a, h
01dc 01dc d ba
01dc 01dc u 01 01
01dc 01dc s         cp      d
01dd 01dd d 2004
01dd 01dd u 02 01
01dd 01dd s         jr      nz, sd_rinc
01df 01df d 7d
01df 01df u 01 01
01df 01df s         ld      a, l
01e0 01e0 d bb
01e0 01e0 u 01 01
01e0 01e0 s         cp      e
01e1 01e1 d 2803
01e1 01e1 u 02 01
01e1 01e1 s         jr      z, sd_next
01e3 01e3 s sd_rinc:
01e3 01e3 d 23
01e3 01e3 u 01 01
01e3 01e3 s         inc     hl
01e4 01e4 d 18f1
01e4 01e4 u 02 01
01e4 01e4 s         jr      sd_read
01e6 01e6 s 
01e6 01e6 s sd_next:
01e6 01e6 d cb00
01e6 01e6 u 02 01
01e6 01e6 s         rlc     b
01e8 01e8 d 0d
01e8 01e8 u 01 01
01e8 01e8 s         dec     c
01e9 01e9 d 20d8
01e9 01e9 u 02 01
01e9 01e9 s         jr      nz, sd_bit
01eb 01eb s 
01eb 01eb d 78
01eb 01eb u 01 01
01eb 01eb s         ld      a, b
01ec 01ec d fe01
01ec 01ec u 02 01
01ec 01ec s         cp      1
01ee 01ee d 2004
01ee 01ee u 02 01
01ee 01ee s         jr      nz, sd_done
01f0 01f0 d 06fe
01f0 01f0 u 02 01
01f0 01f0 s         ld      b, 0FEh
01f2 01f2 d 18cd
01f2 01f2 u 02 01
01f2 01f2 s         jr      sd_outer
01f4 01f4 s 
01f4 01f4 s sd_done:
01f4 01f4 d d1
01f4 01f4 u 01 01
01f4 01f4 s         pop     de
01f5 01f5 d e1
01f5 01f5 u 01 01
01f5 01f5 s         pop     hl
01f6 01f6 d af
01f6 01f6 u 01 01
01f6 01f6 s         xor     a
01f7 01f7 d c9
01f7 01f7 u 01 01
01f7 01f7 s         ret
01f8 01f8 s 
01f8 01f8 s sd_fail:
01f8 01f8 d d1
01f8 01f8 u 01 01
01f8 01f8 s         pop     de
01f9 01f9 d e1
01f9 01f9 u 01 01
01f9 01f9 s         pop     hl
01fa 01fa d 3e01
01fa 01fa u 02 01
01fa 01fa s         ld      a, 1
01fc 01fc d b7
01fc 01fc u 01 01
01fc 01fc s         or      a
01fd 01fd d c9
01fd 01fd u 01 01
01fd 01fd s         ret
01fe 01fe s 
01fe 01fe s ; ============================================================================
01fe 01fe s ; Address Data Test
01fe 01fe s ; Input: HL = start, DE = end
01fe 01fe s ; Output: Z=pass, NZ=fail
01fe 01fe s ; ============================================================================
01fe 01fe s address_data:
01fe 01fe d e5
01fe 01fe u 01 01
01fe 01fe s         push    hl
01ff 01ff d d5
01ff 01ff u 01 01
01ff 01ff s         push    de
0200 0200 s 
0200 0200 s         ; Write low bytes
0200 0200 d d1
0200 0200 u 01 01
0200 0200 s         pop     de
0201 0201 d e1
0201 0201 u 01 01
0201 0201 s         pop     hl
0202 0202 d e5
0202 0202 u 01 01
0202 0202 s         push    hl
0203 0203 d d5
0203 0203 u 01 01
0203 0203 s         push    de
0204 0204 s 
0204 0204 s ad_wlo:
0204 0204 d 75
0204 0204 u 01 01
0204 0204 s         ld      (hl), l
0205 0205 d 7c
0205 0205 u 01 01
0205 0205 s         ld      a, h
0206 0206 d ba
0206 0206 u 01 01
0206 0206 s         cp      d
0207 0207 d 2004
0207 0207 u 02 01
0207 0207 s         jr      nz, ad_wlinc
0209 0209 d 7d
0209 0209 u 01 01
0209 0209 s         ld      a, l
020a 020a d bb
020a 020a u 01 01
020a 020a s         cp      e
020b 020b d 2803
020b 020b u 02 01
020b 020b s         jr      z, ad_vlo
020d 020d s ad_wlinc:
020d 020d d 23
020d 020d u 01 01
020d 020d s         inc     hl
020e 020e d 18f4
020e 020e u 02 01
020e 020e s         jr      ad_wlo
0210 0210 s 
0210 0210 s ad_vlo:
0210 0210 s         ; Verify low bytes
0210 0210 d d1
0210 0210 u 01 01
0210 0210 s         pop     de
0211 0211 d e1
0211 0211 u 01 01
0211 0211 s         pop     hl
0212 0212 d e5
0212 0212 u 01 01
0212 0212 s         push    hl
0213 0213 d d5
0213 0213 u 01 01
0213 0213 s         push    de
0214 0214 s 
0214 0214 s ad_rlo:
0214 0214 d 7e
0214 0214 u 01 01
0214 0214 s         ld      a, (hl)
0215 0215 d bd
0215 0215 u 01 01
0215 0215 s         cp      l
0216 0216 d 2032
0216 0216 u 02 01
0216 0216 s         jr      nz, ad_fail
0218 0218 d 7c
0218 0218 u 01 01
0218 0218 s         ld      a, h
0219 0219 d ba
0219 0219 u 01 01
0219 0219 s         cp      d
021a 021a d 2004
021a 021a u 02 01
021a 021a s         jr      nz, ad_rlinc
021c 021c d 7d
021c 021c u 01 01
021c 021c s         ld      a, l
021d 021d d bb
021d 021d u 01 01
021d 021d s         cp      e
021e 021e d 2803
021e 021e u 02 01
021e 021e s         jr      z, ad_whi
0220 0220 s ad_rlinc:
0220 0220 d 23
0220 0220 u 01 01
0220 0220 s         inc     hl
0221 0221 d 18f1
0221 0221 u 02 01
0221 0221 s         jr      ad_rlo
0223 0223 s 
0223 0223 s ad_whi:
0223 0223 s         ; Write high bytes
0223 0223 d d1
0223 0223 u 01 01
0223 0223 s         pop     de
0224 0224 d e1
0224 0224 u 01 01
0224 0224 s         pop     hl
0225 0225 d e5
0225 0225 u 01 01
0225 0225 s         push    hl
0226 0226 d d5
0226 0226 u 01 01
0226 0226 s         push    de
0227 0227 s 
0227 0227 s ad_wh:
0227 0227 d 74
0227 0227 u 01 01
0227 0227 s         ld      (hl), h
0228 0228 d 7c
0228 0228 u 01 01
0228 0228 s         ld      a, h
0229 0229 d ba
0229 0229 u 01 01
0229 0229 s         cp      d
022a 022a d 2004
022a 022a u 02 01
022a 022a s         jr      nz, ad_whinc
022c 022c d 7d
022c 022c u 01 01
022c 022c s         ld      a, l
022d 022d d bb
022d 022d u 01 01
022d 022d s         cp      e
022e 022e d 2803
022e 022e u 02 01
022e 022e s         jr      z, ad_vhi
0230 0230 s ad_whinc:
0230 0230 d 23
0230 0230 u 01 01
0230 0230 s         inc     hl
0231 0231 d 18f4
0231 0231 u 02 01
0231 0231 s         jr      ad_wh
0233 0233 s 
0233 0233 s ad_vhi:
0233 0233 s         ; Verify high bytes
0233 0233 d d1
0233 0233 u 01 01
0233 0233 s         pop     de
0234 0234 d e1
0234 0234 u 01 01
0234 0234 s         pop     hl
0235 0235 d e5
0235 0235 u 01 01
0235 0235 s         push    hl
0236 0236 d d5
0236 0236 u 01 01
0236 0236 s         push    de
0237 0237 s 
0237 0237 s ad_rhi:
0237 0237 d 7e
0237 0237 u 01 01
0237 0237 s         ld      a, (hl)
0238 0238 d bc
0238 0238 u 01 01
0238 0238 s         cp      h
0239 0239 d 200f
0239 0239 u 02 01
0239 0239 s         jr      nz, ad_fail
023b 023b d 7c
023b 023b u 01 01
023b 023b s         ld      a, h
023c 023c d ba
023c 023c u 01 01
023c 023c s         cp      d
023d 023d d 2004
023d 023d u 02 01
023d 023d s         jr      nz, ad_rhinc
023f 023f d 7d
023f 023f u 01 01
023f 023f s         ld      a, l
0240 0240 d bb
0240 0240 u 01 01
0240 0240 s         cp      e
0241 0241 d 2803
0241 0241 u 02 01
0241 0241 s         jr      z, ad_done
0243 0243 s ad_rhinc:
0243 0243 d 23
0243 0243 u 01 01
0243 0243 s         inc     hl
0244 0244 d 18f1
0244 0244 u 02 01
0244 0244 s         jr      ad_rhi
0246 0246 s 
0246 0246 s ad_done:
0246 0246 d d1
0246 0246 u 01 01
0246 0246 s         pop     de
0247 0247 d e1
0247 0247 u 01 01
0247 0247 s         pop     hl
0248 0248 d af
0248 0248 u 01 01
0248 0248 s         xor     a
0249 0249 d c9
0249 0249 u 01 01
0249 0249 s         ret
024a 024a s 
024a 024a s ad_fail:
024a 024a d d1
024a 024a u 01 01
024a 024a s         pop     de
024b 024b d e1
024b 024b u 01 01
024b 024b s         pop     hl
024c 024c d 3e01
024c 024c u 02 01
024c 024c s         ld      a, 1
024e 024e d b7
024e 024e u 01 01
024e 024e s         or      a
024f 024f d c9
024f 024f u 01 01
024f 024f s         ret
0250 0250 s 
0250 0250 s ; ============================================================================
0250 0250 s ; Video RAM Test (SY6545 CRTC transparent addressing)
0250 0250 s ; Tests 2KB of VRAM at 0x0000-0x07FF via CRTC registers
0250 0250 s ; ============================================================================
0250 0250 s vram_test:
0250 0250 d 117704
0250 0250 u 03 01
0250 0250 s         ld      de, msg_vram
0253 0253 d cdb903
0253 0253 u 03 01
0253 0253 s         call    print
0256 0256 s 
0256 0256 s         ; Save current VRAM contents to backup buffer at 0x9000
0256 0256 d 210000
0256 0256 u 03 01
0256 0256 s         ld      hl, 0               ; VRAM address
0259 0259 d 110090
0259 0259 u 03 01
0259 0259 s         ld      de, 09000h          ; Backup buffer
025c 025c d 010008
025c 025c u 03 01
025c 025c s         ld      bc, 0800h           ; 2KB
025f 025f s vram_save:
025f 025f d c5
025f 025f u 01 01
025f 025f s         push    bc
0260 0260 d d5
0260 0260 u 01 01
0260 0260 s         push    de
0261 0261 d cd6f03
0261 0261 u 03 01
0261 0261 s         call    crtc_read           ; Read VRAM[HL] -> A
0264 0264 d d1
0264 0264 u 01 01
0264 0264 s         pop     de
0265 0265 d 12
0265 0265 u 01 01
0265 0265 s         ld      (de), a             ; Save to backup
0266 0266 d 13
0266 0266 u 01 01
0266 0266 s         inc     de
0267 0267 d 23
0267 0267 u 01 01
0267 0267 s         inc     hl
0268 0268 d c1
0268 0268 u 01 01
0268 0268 s         pop     bc
0269 0269 d 0b
0269 0269 u 01 01
0269 0269 s         dec     bc
026a 026a d 78
026a 026a u 01 01
026a 026a s         ld      a, b
026b 026b d b1
026b 026b u 01 01
026b 026b s         or      c
026c 026c d 20f1
026c 026c u 02 01
026c 026c s         jr      nz, vram_save
026e 026e s 
026e 026e s         ; Perform sliding-data test on VRAM 0x0000-0x07FF
026e 026e d 210000
026e 026e u 03 01
026e 026e s         ld      hl, 0
0271 0271 d 11ff07
0271 0271 u 03 01
0271 0271 s         ld      de, 07FFh
0274 0274 d cdb102
0274 0274 u 03 01
0274 0274 s         call    vram_sliding
0277 0277 d 2015
0277 0277 u 02 01
0277 0277 s         jr      nz, vram_fail
0279 0279 s 
0279 0279 s         ; Perform address-data test on VRAM 0x0000-0x07FF
0279 0279 d 210000
0279 0279 u 03 01
0279 0279 s         ld      hl, 0
027c 027c d 11ff07
027c 027c u 03 01
027c 027c s         ld      de, 07FFh
027f 027f d cd0303
027f 027f u 03 01
027f 027f s         call    vram_address
0282 0282 d 200a
0282 0282 u 02 01
0282 0282 s         jr      nz, vram_fail
0284 0284 s 
0284 0284 s         ; Restore VRAM contents from backup
0284 0284 d cd9802
0284 0284 u 03 01
0284 0284 s         call    vram_restore
0287 0287 s 
0287 0287 d 119104
0287 0287 u 03 01
0287 0287 s         ld      de, msg_pass
028a 028a d cdb903
028a 028a u 03 01
028a 028a s         call    print
028d 028d d c9
028d 028d u 01 01
028d 028d s         ret
028e 028e s 
028e 028e s vram_fail:
028e 028e s         ; Restore VRAM contents even on failure
028e 028e d cd9802
028e 028e u 03 01
028e 028e s         call    vram_restore
0291 0291 s 
0291 0291 d 119804
0291 0291 u 03 01
0291 0291 s         ld      de, msg_fail
0294 0294 d cdb903
0294 0294 u 03 01
0294 0294 s         call    print
0297 0297 d c9
0297 0297 u 01 01
0297 0297 s         ret
0298 0298 s 
0298 0298 s vram_restore:
0298 0298 d 210000
0298 0298 u 03 01
0298 0298 s         ld      hl, 0               ; VRAM address
029b 029b d 110090
029b 029b u 03 01
029b 029b s         ld      de, 09000h          ; Backup buffer
029e 029e d 010008
029e 029e u 03 01
029e 029e s         ld      bc, 0800h           ; 2KB
02a1 02a1 s vram_rest_loop:
02a1 02a1 d c5
02a1 02a1 u 01 01
02a1 02a1 s         push    bc
02a2 02a2 d e5
02a2 02a2 u 01 01
02a2 02a2 s         push    hl
02a3 02a3 d 1a
02a3 02a3 u 01 01
02a3 02a3 s         ld      a, (de)             ; Get from backup
02a4 02a4 d cd9003
02a4 02a4 u 03 01
02a4 02a4 s         call    crtc_write          ; Write VRAM[HL] <- A
02a7 02a7 d e1
02a7 02a7 u 01 01
02a7 02a7 s         pop     hl
02a8 02a8 d 23
02a8 02a8 u 01 01
02a8 02a8 s         inc     hl
02a9 02a9 d 13
02a9 02a9 u 01 01
02a9 02a9 s         inc     de
02aa 02aa d c1
02aa 02aa u 01 01
02aa 02aa s         pop     bc
02ab 02ab d 0b
02ab 02ab u 01 01
02ab 02ab s         dec     bc
02ac 02ac d 78
02ac 02ac u 01 01
02ac 02ac s         ld      a, b
02ad 02ad d b1
02ad 02ad u 01 01
02ad 02ad s         or      c
02ae 02ae d 20f1
02ae 02ae u 02 01
02ae 02ae s         jr      nz, vram_rest_loop
02b0 02b0 d c9
02b0 02b0 u 01 01
02b0 02b0 s         ret
02b1 02b1 s 
02b1 02b1 s ; ============================================================================
02b1 02b1 s ; VRAM Sliding Data Test
02b1 02b1 s ; Input: HL = start VRAM addr, DE = end VRAM addr
02b1 02b1 s ; Output: Z=pass, NZ=fail
02b1 02b1 s ; ============================================================================
02b1 02b1 s vram_sliding:
02b1 02b1 d e5
02b1 02b1 u 01 01
02b1 02b1 s         push    hl
02b2 02b2 d d5
02b2 02b2 u 01 01
02b2 02b2 s         push    de
02b3 02b3 s 
02b3 02b3 d 0601
02b3 02b3 u 02 01
02b3 02b3 s         ld      b, 1                ; Initial pattern 0x01
02b5 02b5 s vsd_outer:
02b5 02b5 d 0e08
02b5 02b5 u 02 01
02b5 02b5 s         ld      c, 8                ; 8 bit positions
02b7 02b7 s 
02b7 02b7 s vsd_bit:
02b7 02b7 d d1
02b7 02b7 u 01 01
02b7 02b7 s         pop     de
02b8 02b8 d e1
02b8 02b8 u 01 01
02b8 02b8 s         pop     hl
02b9 02b9 d e5
02b9 02b9 u 01 01
02b9 02b9 s         push    hl
02ba 02ba d d5
02ba 02ba u 01 01
02ba 02ba s         push    de
02bb 02bb s 
02bb 02bb s         ; Write pattern B to all VRAM locations
02bb 02bb s vsd_write:
02bb 02bb d c5
02bb 02bb u 01 01
02bb 02bb s         push    bc
02bc 02bc d d5
02bc 02bc u 01 01
02bc 02bc s         push    de
02bd 02bd d e5
02bd 02bd u 01 01
02bd 02bd s         push    hl
02be 02be d 78
02be 02be u 01 01
02be 02be s         ld      a, b                ; Pattern to write
02bf 02bf d cd9003
02bf 02bf u 03 01
02bf 02bf s         call    crtc_write          ; Write to VRAM[HL]
02c2 02c2 d e1
02c2 02c2 u 01 01
02c2 02c2 s         pop     hl
02c3 02c3 d d1
02c3 02c3 u 01 01
02c3 02c3 s         pop     de
02c4 02c4 d c1
02c4 02c4 u 01 01
02c4 02c4 s         pop     bc
02c5 02c5 s         ; Check if HL == DE (end)
02c5 02c5 d 7c
02c5 02c5 u 01 01
02c5 02c5 s         ld      a, h
02c6 02c6 d ba
02c6 02c6 u 01 01
02c6 02c6 s         cp      d
02c7 02c7 d 2004
02c7 02c7 u 02 01
02c7 02c7 s         jr      nz, vsd_winc
02c9 02c9 d 7d
02c9 02c9 u 01 01
02c9 02c9 s         ld      a, l
02ca 02ca d bb
02ca 02ca u 01 01
02ca 02ca s         cp      e
02cb 02cb d 2803
02cb 02cb u 02 01
02cb 02cb s         jr      z, vsd_verify
02cd 02cd s vsd_winc:
02cd 02cd d 23
02cd 02cd u 01 01
02cd 02cd s         inc     hl
02ce 02ce d 18eb
02ce 02ce u 02 01
02ce 02ce s         jr      vsd_write
02d0 02d0 s 
02d0 02d0 s vsd_verify:
02d0 02d0 s         ; Verify pattern B in all VRAM locations
02d0 02d0 d d1
02d0 02d0 u 01 01
02d0 02d0 s         pop     de
02d1 02d1 d e1
02d1 02d1 u 01 01
02d1 02d1 s         pop     hl
02d2 02d2 d e5
02d2 02d2 u 01 01
02d2 02d2 s         push    hl
02d3 02d3 d d5
02d3 02d3 u 01 01
02d3 02d3 s         push    de
02d4 02d4 s 
02d4 02d4 s vsd_read:
02d4 02d4 d c5
02d4 02d4 u 01 01
02d4 02d4 s         push    bc
02d5 02d5 d d5
02d5 02d5 u 01 01
02d5 02d5 s         push    de
02d6 02d6 d e5
02d6 02d6 u 01 01
02d6 02d6 s         push    hl
02d7 02d7 d cd6f03
02d7 02d7 u 03 01
02d7 02d7 s         call    crtc_read           ; Read VRAM[HL] -> A
02da 02da d e1
02da 02da u 01 01
02da 02da s         pop     hl
02db 02db d d1
02db 02db u 01 01
02db 02db s         pop     de
02dc 02dc d c1
02dc 02dc u 01 01
02dc 02dc s         pop     bc                  ; Restore pattern (B) and counter (C)
02dd 02dd d b8
02dd 02dd u 01 01
02dd 02dd s         cp      b                   ; Compare read value (A) with expected pattern (B)
02de 02de d 201d
02de 02de u 02 01
02de 02de s         jr      nz, vsd_fail
02e0 02e0 s         ; Check if HL == DE (end)
02e0 02e0 d 7c
02e0 02e0 u 01 01
02e0 02e0 s         ld      a, h
02e1 02e1 d ba
02e1 02e1 u 01 01
02e1 02e1 s         cp      d
02e2 02e2 d 2004
02e2 02e2 u 02 01
02e2 02e2 s         jr      nz, vsd_rinc
02e4 02e4 d 7d
02e4 02e4 u 01 01
02e4 02e4 s         ld      a, l
02e5 02e5 d bb
02e5 02e5 u 01 01
02e5 02e5 s         cp      e
02e6 02e6 d 2803
02e6 02e6 u 02 01
02e6 02e6 s         jr      z, vsd_next
02e8 02e8 s vsd_rinc:
02e8 02e8 d 23
02e8 02e8 u 01 01
02e8 02e8 s         inc     hl
02e9 02e9 d 18e9
02e9 02e9 u 02 01
02e9 02e9 s         jr      vsd_read
02eb 02eb s 
02eb 02eb s vsd_next:
02eb 02eb d cb00
02eb 02eb u 02 01
02eb 02eb s         rlc     b                   ; Rotate pattern left
02ed 02ed d 0d
02ed 02ed u 01 01
02ed 02ed s         dec     c                   ; Decrement bit counter
02ee 02ee d 20c7
02ee 02ee u 02 01
02ee 02ee s         jr      nz, vsd_bit
02f0 02f0 s 
02f0 02f0 s         ; After 8 rotations of 0x01, switch to 0xFE
02f0 02f0 d 78
02f0 02f0 u 01 01
02f0 02f0 s         ld      a, b
02f1 02f1 d fe01
02f1 02f1 u 02 01
02f1 02f1 s         cp      1
02f3 02f3 d 2004
02f3 02f3 u 02 01
02f3 02f3 s         jr      nz, vsd_done
02f5 02f5 d 06fe
02f5 02f5 u 02 01
02f5 02f5 s         ld      b, 0FEh
02f7 02f7 d 18bc
02f7 02f7 u 02 01
02f7 02f7 s         jr      vsd_outer
02f9 02f9 s 
02f9 02f9 s vsd_done:
02f9 02f9 d d1
02f9 02f9 u 01 01
02f9 02f9 s         pop     de
02fa 02fa d e1
02fa 02fa u 01 01
02fa 02fa s         pop     hl
02fb 02fb d af
02fb 02fb u 01 01
02fb 02fb s         xor     a                   ; Z=pass
02fc 02fc d c9
02fc 02fc u 01 01
02fc 02fc s         ret
02fd 02fd s 
02fd 02fd s vsd_fail:
02fd 02fd d d1
02fd 02fd u 01 01
02fd 02fd s         pop     de
02fe 02fe d e1
02fe 02fe u 01 01
02fe 02fe s         pop     hl
02ff 02ff d 3e01
02ff 02ff u 02 01
02ff 02ff s         ld      a, 1
0301 0301 d b7
0301 0301 u 01 01
0301 0301 s         or      a                   ; NZ=fail
0302 0302 d c9
0302 0302 u 01 01
0302 0302 s         ret
0303 0303 s 
0303 0303 s ; ============================================================================
0303 0303 s ; VRAM Address Data Test
0303 0303 s ; Input: HL = start VRAM addr, DE = end VRAM addr
0303 0303 s ; Output: Z=pass, NZ=fail
0303 0303 s ; ============================================================================
0303 0303 s vram_address:
0303 0303 d e5
0303 0303 u 01 01
0303 0303 s         push    hl
0304 0304 d d5
0304 0304 u 01 01
0304 0304 s         push    de
0305 0305 s 
0305 0305 s         ; Write low byte of address to each location
0305 0305 d d1
0305 0305 u 01 01
0305 0305 s         pop     de
0306 0306 d e1
0306 0306 u 01 01
0306 0306 s         pop     hl
0307 0307 d e5
0307 0307 u 01 01
0307 0307 s         push    hl
0308 0308 d d5
0308 0308 u 01 01
0308 0308 s         push    de
0309 0309 s 
0309 0309 s vad_wlo:
0309 0309 d d5
0309 0309 u 01 01
0309 0309 s         push    de
030a 030a d e5
030a 030a u 01 01
030a 030a s         push    hl
030b 030b d 7d
030b 030b u 01 01
030b 030b s         ld      a, l                ; Low byte of address
030c 030c d cd9003
030c 030c u 03 01
030c 030c s         call    crtc_write          ; Write to VRAM[HL]
030f 030f d e1
030f 030f u 01 01
030f 030f s         pop     hl
0310 0310 d d1
0310 0310 u 01 01
0310 0310 s         pop     de
0311 0311 s         ; Check if HL == DE
0311 0311 d 7c
0311 0311 u 01 01
0311 0311 s         ld      a, h
0312 0312 d ba
0312 0312 u 01 01
0312 0312 s         cp      d
0313 0313 d 2004
0313 0313 u 02 01
0313 0313 s         jr      nz, vad_wlinc
0315 0315 d 7d
0315 0315 u 01 01
0315 0315 s         ld      a, l
0316 0316 d bb
0316 0316 u 01 01
0316 0316 s         cp      e
0317 0317 d 2803
0317 0317 u 02 01
0317 0317 s         jr      z, vad_vlo
0319 0319 s vad_wlinc:
0319 0319 d 23
0319 0319 u 01 01
0319 0319 s         inc     hl
031a 031a d 18ed
031a 031a u 02 01
031a 031a s         jr      vad_wlo
031c 031c s 
031c 031c s vad_vlo:
031c 031c s         ; Verify low bytes
031c 031c d d1
031c 031c u 01 01
031c 031c s         pop     de
031d 031d d e1
031d 031d u 01 01
031d 031d s         pop     hl
031e 031e d e5
031e 031e u 01 01
031e 031e s         push    hl
031f 031f d d5
031f 031f u 01 01
031f 031f s         push    de
0320 0320 s 
0320 0320 s vad_rlo:
0320 0320 d d5
0320 0320 u 01 01
0320 0320 s         push    de
0321 0321 d e5
0321 0321 u 01 01
0321 0321 s         push    hl
0322 0322 d cd6f03
0322 0322 u 03 01
0322 0322 s         call    crtc_read           ; Read VRAM[HL] -> A
0325 0325 d e1
0325 0325 u 01 01
0325 0325 s         pop     hl
0326 0326 d d1
0326 0326 u 01 01
0326 0326 s         pop     de
0327 0327 d bd
0327 0327 u 01 01
0327 0327 s         cp      l                   ; Compare with expected (low byte of addr)
0328 0328 d 203f
0328 0328 u 02 01
0328 0328 s         jr      nz, vad_fail
032a 032a s         ; Check if HL == DE
032a 032a d 7c
032a 032a u 01 01
032a 032a s         ld      a, h
032b 032b d ba
032b 032b u 01 01
032b 032b s         cp      d
032c 032c d 2004
032c 032c u 02 01
032c 032c s         jr      nz, vad_rlinc
032e 032e d 7d
032e 032e u 01 01
032e 032e s         ld      a, l
032f 032f d bb
032f 032f u 01 01
032f 032f s         cp      e
0330 0330 d 2803
0330 0330 u 02 01
0330 0330 s         jr      z, vad_whi
0332 0332 s vad_rlinc:
0332 0332 d 23
0332 0332 u 01 01
0332 0332 s         inc     hl
0333 0333 d 18eb
0333 0333 u 02 01
0333 0333 s         jr      vad_rlo
0335 0335 s 
0335 0335 s vad_whi:
0335 0335 s         ; Write high byte of address to each location
0335 0335 d d1
0335 0335 u 01 01
0335 0335 s         pop     de
0336 0336 d e1
0336 0336 u 01 01
0336 0336 s         pop     hl
0337 0337 d e5
0337 0337 u 01 01
0337 0337 s         push    hl
0338 0338 d d5
0338 0338 u 01 01
0338 0338 s         push    de
0339 0339 s 
0339 0339 s vad_wh:
0339 0339 d d5
0339 0339 u 01 01
0339 0339 s         push    de
033a 033a d e5
033a 033a u 01 01
033a 033a s         push    hl
033b 033b d 7c
033b 033b u 01 01
033b 033b s         ld      a, h                ; High byte of address
033c 033c d cd9003
033c 033c u 03 01
033c 033c s         call    crtc_write          ; Write to VRAM[HL]
033f 033f d e1
033f 033f u 01 01
033f 033f s         pop     hl
0340 0340 d d1
0340 0340 u 01 01
0340 0340 s         pop     de
0341 0341 s         ; Check if HL == DE
0341 0341 d 7c
0341 0341 u 01 01
0341 0341 s         ld      a, h
0342 0342 d ba
0342 0342 u 01 01
0342 0342 s         cp      d
0343 0343 d 2004
0343 0343 u 02 01
0343 0343 s         jr      nz, vad_whinc
0345 0345 d 7d
0345 0345 u 01 01
0345 0345 s         ld      a, l
0346 0346 d bb
0346 0346 u 01 01
0346 0346 s         cp      e
0347 0347 d 2803
0347 0347 u 02 01
0347 0347 s         jr      z, vad_vhi
0349 0349 s vad_whinc:
0349 0349 d 23
0349 0349 u 01 01
0349 0349 s         inc     hl
034a 034a d 18ed
034a 034a u 02 01
034a 034a s         jr      vad_wh
034c 034c s 
034c 034c s vad_vhi:
034c 034c s         ; Verify high bytes
034c 034c d d1
034c 034c u 01 01
034c 034c s         pop     de
034d 034d d e1
034d 034d u 01 01
034d 034d s         pop     hl
034e 034e d e5
034e 034e u 01 01
034e 034e s         push    hl
034f 034f d d5
034f 034f u 01 01
034f 034f s         push    de
0350 0350 s 
0350 0350 s vad_rhi:
0350 0350 d d5
0350 0350 u 01 01
0350 0350 s         push    de
0351 0351 d e5
0351 0351 u 01 01
0351 0351 s         push    hl
0352 0352 d cd6f03
0352 0352 u 03 01
0352 0352 s         call    crtc_read           ; Read VRAM[HL] -> A
0355 0355 d e1
0355 0355 u 01 01
0355 0355 s         pop     hl
0356 0356 d d1
0356 0356 u 01 01
0356 0356 s         pop     de
0357 0357 d bc
0357 0357 u 01 01
0357 0357 s         cp      h                   ; Compare with expected (high byte of addr)
0358 0358 d 200f
0358 0358 u 02 01
0358 0358 s         jr      nz, vad_fail
035a 035a s         ; Check if HL == DE
035a 035a d 7c
035a 035a u 01 01
035a 035a s         ld      a, h
035b 035b d ba
035b 035b u 01 01
035b 035b s         cp      d
035c 035c d 2004
035c 035c u 02 01
035c 035c s         jr      nz, vad_rhinc
035e 035e d 7d
035e 035e u 01 01
035e 035e s         ld      a, l
035f 035f d bb
035f 035f u 01 01
035f 035f s         cp      e
0360 0360 d 2803
0360 0360 u 02 01
0360 0360 s         jr      z, vad_done
0362 0362 s vad_rhinc:
0362 0362 d 23
0362 0362 u 01 01
0362 0362 s         inc     hl
0363 0363 d 18eb
0363 0363 u 02 01
0363 0363 s         jr      vad_rhi
0365 0365 s 
0365 0365 s vad_done:
0365 0365 d d1
0365 0365 u 01 01
0365 0365 s         pop     de
0366 0366 d e1
0366 0366 u 01 01
0366 0366 s         pop     hl
0367 0367 d af
0367 0367 u 01 01
0367 0367 s         xor     a                   ; Z=pass
0368 0368 d c9
0368 0368 u 01 01
0368 0368 s         ret
0369 0369 s 
0369 0369 s vad_fail:
0369 0369 d d1
0369 0369 u 01 01
0369 0369 s         pop     de
036a 036a d e1
036a 036a u 01 01
036a 036a s         pop     hl
036b 036b d 3e01
036b 036b u 02 01
036b 036b s         ld      a, 1
036d 036d d b7
036d 036d u 01 01
036d 036d s         or      a                   ; NZ=fail
036e 036e d c9
036e 036e u 01 01
036e 036e s         ret
036f 036f s 
036f 036f s ; ============================================================================
036f 036f s ; CRTC VRAM Read - Read byte from VRAM via SY6545 transparent addressing
036f 036f s ; Input: HL = VRAM address (0x0000-0x07FF)
036f 036f s ; Output: A = byte read
036f 036f s ; Clobbers: BC
036f 036f s ; 
036f 036f s ; Protocol (from diag4.mac cr4/cr6):
036f 036f s ;   1. OUT 0x1C, 0x12       (select R18 - Update Address High)
036f 036f s ;   2. OUT 0x1D, H          (write high byte)
036f 036f s ;   3. OUT 0x1C, 0x13       (select R19 - Update Address Low)  
036f 036f s ;   4. OUT 0x1D, L          (write low byte)
036f 036f s ;   5. OUT 0x1C, 0x1F       (strobe command)
036f 036f s ;   6. Wait for IN 0x1C bit 7 = 1 (Update Ready)
036f 036f s ;   7. IN 0x1F              (read VRAM data)
036f 036f s ; ============================================================================
036f 036f s crtc_read:
036f 036f d e5
036f 036f u 01 01
036f 036f s         push    hl
0370 0370 s         ; Mask address to 11 bits (0-0x7FF)
0370 0370 d 7c
0370 0370 u 01 01
0370 0370 s         ld      a, h
0371 0371 d e607
0371 0371 u 02 01
0371 0371 s         and     07h
0373 0373 d 67
0373 0373 u 01 01
0373 0373 s         ld      h, a
0374 0374 s 
0374 0374 s         ; Select R18 and write high byte
0374 0374 d 3e12
0374 0374 u 02 01
0374 0374 s         ld      a, 012h             ; R18 - Update Address High
0376 0376 d d31c
0376 0376 u 02 01
0376 0376 s         out     (crtc_reg), a
0378 0378 d 7c
0378 0378 u 01 01
0378 0378 s         ld      a, h
0379 0379 d d31d
0379 0379 u 02 01
0379 0379 s         out     (crtc_data), a
037b 037b s 
037b 037b s         ; Select R19 and write low byte
037b 037b d 3e13
037b 037b u 02 01
037b 037b s         ld      a, 013h             ; R19 - Update Address Low
037d 037d d d31c
037d 037d u 02 01
037d 037d s         out     (crtc_reg), a
037f 037f d 7d
037f 037f u 01 01
037f 037f s         ld      a, l
0380 0380 d d31d
0380 0380 u 02 01
0380 0380 s         out     (crtc_data), a
0382 0382 s 
0382 0382 s         ; Send strobe command
0382 0382 d 3e1f
0382 0382 u 02 01
0382 0382 s         ld      a, strcmd
0384 0384 d d31c
0384 0384 u 02 01
0384 0384 s         out     (crtc_reg), a
0386 0386 s 
0386 0386 s         ; Wait for Update Ready (bit 7 of port 0x1C)
0386 0386 s crtc_read_wait:
0386 0386 d db1c
0386 0386 u 02 01
0386 0386 s         in      a, (crtc_reg)
0388 0388 d b7
0388 0388 u 01 01
0388 0388 s         or      a
0389 0389 d f28603
0389 0389 u 03 01
0389 0389 s         jp      p, crtc_read_wait   ; Loop while bit 7 = 0
038c 038c s 
038c 038c s         ; Read VRAM data
038c 038c d db1f
038c 038c u 02 01
038c 038c s         in      a, (crtc_vram)
038e 038e s 
038e 038e d e1
038e 038e u 01 01
038e 038e s         pop     hl
038f 038f d c9
038f 038f u 01 01
038f 038f s         ret
0390 0390 s 
0390 0390 s ; ============================================================================
0390 0390 s ; CRTC VRAM Write - Write byte to VRAM via SY6545 transparent addressing
0390 0390 s ; Input: HL = VRAM address (0x0000-0x07FF), A = byte to write
0390 0390 s ; Clobbers: BC
0390 0390 s ;
0390 0390 s ; Protocol (from diag4.mac cr5/cr6):
0390 0390 s ;   1-6. Same as read (set address and strobe)
0390 0390 s ;   7. OUT 0x1F, A          (write VRAM data)
0390 0390 s ;   8. Wait for IN 0x1C bit 7 = 1 (write complete)
0390 0390 s ; ============================================================================
0390 0390 s crtc_write:
0390 0390 d e5
0390 0390 u 01 01
0390 0390 s         push    hl
0391 0391 d f5
0391 0391 u 01 01
0391 0391 s         push    af                  ; Save data byte
0392 0392 s         ; Mask address to 11 bits (0-0x7FF)
0392 0392 d 7c
0392 0392 u 01 01
0392 0392 s         ld      a, h
0393 0393 d e607
0393 0393 u 02 01
0393 0393 s         and     07h
0395 0395 d 67
0395 0395 u 01 01
0395 0395 s         ld      h, a
0396 0396 s 
0396 0396 s         ; Select R18 and write high byte
0396 0396 d 3e12
0396 0396 u 02 01
0396 0396 s         ld      a, 012h             ; R18 - Update Address High
0398 0398 d d31c
0398 0398 u 02 01
0398 0398 s         out     (crtc_reg), a
039a 039a d 7c
039a 039a u 01 01
039a 039a s         ld      a, h
039b 039b d d31d
039b 039b u 02 01
039b 039b s         out     (crtc_data), a
039d 039d s 
039d 039d s         ; Select R19 and write low byte
039d 039d d 3e13
039d 039d u 02 01
039d 039d s         ld      a, 013h             ; R19 - Update Address Low
039f 039f d d31c
039f 039f u 02 01
039f 039f s         out     (crtc_reg), a
03a1 03a1 d 7d
03a1 03a1 u 01 01
03a1 03a1 s         ld      a, l
03a2 03a2 d d31d
03a2 03a2 u 02 01
03a2 03a2 s         out     (crtc_data), a
03a4 03a4 s 
03a4 03a4 s         ; Send strobe command
03a4 03a4 d 3e1f
03a4 03a4 u 02 01
03a4 03a4 s         ld      a, strcmd
03a6 03a6 d d31c
03a6 03a6 u 02 01
03a6 03a6 s         out     (crtc_reg), a
03a8 03a8 s 
03a8 03a8 s         ; Wait for Update Ready (bit 7 of port 0x1C)
03a8 03a8 s crtc_write_wait1:
03a8 03a8 d db1c
03a8 03a8 u 02 01
03a8 03a8 s         in      a, (crtc_reg)
03aa 03aa d b7
03aa 03aa u 01 01
03aa 03aa s         or      a
03ab 03ab d f2a803
03ab 03ab u 03 01
03ab 03ab s         jp      p, crtc_write_wait1 ; Loop while bit 7 = 0
03ae 03ae s 
03ae 03ae s         ; Write VRAM data
03ae 03ae d f1
03ae 03ae u 01 01
03ae 03ae s         pop     af                  ; Restore data byte
03af 03af d d31f
03af 03af u 02 01
03af 03af s         out     (crtc_vram), a
03b1 03b1 s 
03b1 03b1 s         ; Wait for write complete
03b1 03b1 s crtc_write_wait2:
03b1 03b1 d db1c
03b1 03b1 u 02 01
03b1 03b1 s         in      a, (crtc_reg)
03b3 03b3 d b7
03b3 03b3 u 01 01
03b3 03b3 s         or      a
03b4 03b4 d f2b103
03b4 03b4 u 03 01
03b4 03b4 s         jp      p, crtc_write_wait2 ; Loop while bit 7 = 0
03b7 03b7 s 
03b7 03b7 d e1
03b7 03b7 u 01 01
03b7 03b7 s         pop     hl
03b8 03b8 d c9
03b8 03b8 u 01 01
03b8 03b8 s         ret
03b9 03b9 s 
03b9 03b9 s ; ============================================================================
03b9 03b9 s ; Utility routines
03b9 03b9 s ; ============================================================================
03b9 03b9 s 
03b9 03b9 s print:
03b9 03b9 d 0e09
03b9 03b9 u 02 01
03b9 03b9 s         ld      c, prtstr
03bb 03bb d c30500
03bb 03bb u 03 01
03bb 03bb s         jp      bdos
03be 03be s 
03be 03be s print_hex16:
03be 03be d 7c
03be 03be u 01 01
03be 03be s         ld      a, h
03bf 03bf d cdc303
03bf 03bf u 03 01
03bf 03bf s         call    print_hex8
03c2 03c2 d 7d
03c2 03c2 u 01 01
03c2 03c2 s         ld      a, l
03c3 03c3 s 
03c3 03c3 s print_hex8:
03c3 03c3 d f5
03c3 03c3 u 01 01
03c3 03c3 s         push    af
03c4 03c4 d 0f
03c4 03c4 u 01 01
03c4 03c4 s         rrca
03c5 03c5 d 0f
03c5 03c5 u 01 01
03c5 03c5 s         rrca
03c6 03c6 d 0f
03c6 03c6 u 01 01
03c6 03c6 s         rrca
03c7 03c7 d 0f
03c7 03c7 u 01 01
03c7 03c7 s         rrca
03c8 03c8 d cdcc03
03c8 03c8 u 03 01
03c8 03c8 s         call    print_nibble
03cb 03cb d f1
03cb 03cb u 01 01
03cb 03cb s         pop     af
03cc 03cc s 
03cc 03cc s print_nibble:
03cc 03cc d e60f
03cc 03cc u 02 01
03cc 03cc s         and     00Fh
03ce 03ce d c630
03ce 03ce u 02 01
03ce 03ce s         add     a, 030h
03d0 03d0 d fe3a
03d0 03d0 u 02 01
03d0 03d0 s         cp      03Ah
03d2 03d2 d 3802
03d2 03d2 u 02 01
03d2 03d2 s         jr      c, pn_out
03d4 03d4 d c607
03d4 03d4 u 02 01
03d4 03d4 s         add     a, 7
03d6 03d6 s pn_out:
03d6 03d6 d 5f
03d6 03d6 u 01 01
03d6 03d6 s         ld      e, a
03d7 03d7 d 0e02
03d7 03d7 u 02 01
03d7 03d7 s         ld      c, conout
03d9 03d9 d c30500
03d9 03d9 u 03 01
03d9 03d9 s         jp      bdos
03dc 03dc s 
03dc 03dc s ; ============================================================================
03dc 03dc s ; Messages
03dc 03dc s ; ============================================================================
03dc 03dc s msg_banner:
03dc 03dc d 0d0a
03dc 03dc u 02 02
03dc 03dc s         db      13, 10
03de 03de d 3d3d3d20697a6b617970726f20456d756c61746f7220446961676e6f7374696373203d3d3d0d0a
03de 03de u 27 02
03de 03de s         db      "=== izkaypro Emulator Diagnostics ===", 13, 10
0405 0405 d 4261736564206f6e2064696167342e6d6163202863292031393833204e4c5320496e632e0d0a
0405 0405 u 26 02
0405 0405 s         db      "Based on diag4.mac (c) 1983 NLS Inc.", 13, 10
042b 042b d 0d0a24
042b 042b u 03 02
042b 042b s         db      13, 10, "$"
042e 042e s 
042e 042e s msg_rom:
042e 042e d 524f4d20436865636b73756d20546573743a2024
042e 042e u 14 02
042e 042e s         db      "ROM Checksum Test: $"
0442 0442 s 
0442 0442 s msg_chksum:
0442 0442 d 307824
0442 0442 u 03 02
0442 0442 s         db      "0x$"
0445 0445 s 
0445 0445 s msg_ram1:
0445 0445 d 52414d2054657374203078343030302d3078374646463a2024
0445 0445 u 19 02
0445 0445 s         db      "RAM Test 0x4000-0x7FFF: $"
045e 045e s 
045e 045e s msg_ram2:
045e 045e d 52414d2054657374203078383030302d3078424646463a2024
045e 045e u 19 02
045e 045e s         db      "RAM Test 0x8000-0xBFFF: $"
0477 0477 s 
0477 0477 s msg_vram:
0477 0477 d 5652414d2054657374203078303030302d3078303746463a2024
0477 0477 u 1a 02
0477 0477 s         db      "VRAM Test 0x0000-0x07FF: $"
0491 0491 s 
0491 0491 s msg_pass:
0491 0491 d 504153530d0a24
0491 0491 u 07 02
0491 0491 s         db      "PASS", 13, 10, "$"
0498 0498 s 
0498 0498 s msg_fail:
0498 0498 d 4641494c0d0a24
0498 0498 u 07 02
0498 0498 s         db      "FAIL", 13, 10, "$"
049f 049f s 
049f 049f s msg_done:
049f 049f d 0d0a
049f 049f u 02 02
049f 049f s         db      13, 10
04a1 04a1 d 446961676e6f737469637320636f6d706c6574652e0d0a24
04a1 04a1 u 18 02
04a1 04a1 s         db      "Diagnostics complete.", 13, 10, "$"
04b9 04b9 s 
04b9 04b9 s msg_crlf:
04b9 04b9 d 0d0a24
04b9 04b9 u 03 02
04b9 04b9 s         db      13, 10, "$"
04bc 04bc s 
04bc 04bc s ; ============================================================================
04bc 04bc s ; Stack
04bc 04bc s ; ============================================================================
04bc 04bc s         ds      64
04fc 04fc s stack:
04fc 04fc s 
04fc 04fc s         end
0237 a ad_rhi
0214 a ad_rlo
0193 a ram_test2
03dc a msg_banner
03d6 a pn_out
02cd a vsd_winc
0362 a vad_rhinc
0169 a rom_code_end
0498 a msg_fail
001f v crtc_vram
01fe a address_data
02b1 a vram_sliding
01d0 a sd_winc
02d4 a vsd_read
0349 a vad_whinc
0477 a msg_vram
042e a msg_rom
0233 a ad_vhi
025f a vram_save
0210 a ad_vlo
01d7 a sd_read
02fd a vsd_fail
0223 a ad_whi
0204 a ad_wlo
01c7 a sd_write
02a1 a vram_rest_loop
01f8 a sd_fail
028e a vram_fail
03c3 a print_hex8
04fc a stack
0246 a ad_done
0100 a start
02b5 a vsd_outer
02e8 a vsd_rinc
0303 a vram_address
03cc a print_nibble
0369 a vad_fail
01e3 a sd_rinc
0119 a rom_test
03a8 a crtc_write_wait1
03b1 a crtc_write_wait2
04b9 a msg_crlf
049f a msg_done
03b9 a print
01d3 a sd_verify
0220 a ad_rlinc
0390 a crtc_write
0009 v prtstr
0250 a vram_test
03be a print_hex16
0491 a msg_pass
014f a rom_calc_loop
020d a ad_wlinc
02eb a vsd_next
013f a rom_code_start
02f9 a vsd_done
018d a ram_fail1
01b6 a ram_fail2
001f v strcmd
0350 a vad_rhi
0320 a vad_rlo
0014 v bitport
0332 a vad_rlinc
01e6 a sd_next
01c1 a sd_outer
0002 v conout
01f4 a sd_done
0298 a vram_restore
0155 a rom_no_carry
0365 a vad_done
0319 a vad_wlinc
001d v crtc_data
0005 v bdos
0227 a ad_wh
01c3 a sd_bit
012d a rom_return
034c a vad_vhi
031c a vad_vlo
01bd a sliding_data
001c v crtc_reg
0445 a msg_ram1
045e a msg_ram2
0169 a ram_test
0335 a vad_whi
0309 a vad_wlo
0386 a crtc_read_wait
0442 a msg_chksum
02bb a vsd_write
0243 a ad_rhinc
02b7 a vsd_bit
036f a crtc_read
024a a ad_fail
0339 a vad_wh
02d0 a vsd_verify
0230 a ad_whinc
